; bit clock - (32 +2) * 44.1 * 4 
; minimum frequency is 5.9976 MHz
; 6MHz would probably be a decent margin
; sync pulse 1-4 bit clock width for each frame
; bit output on rising edge of bit clock

; 132 MHz system clock would give a nice multiple of 6MHz

; pin 0 - bclk
; pin 1 - sync pulse

.define FSYNC_IRQ 4

.define SAMPLE_BITS 32
.define CHANNELS 4

.define BIT_COUNTER (SAMPLE_BITS - 1)
.define CHANNEL_COUNTER (CHANNELS - 1)


; output 1 bit every 8 clock cycles, maximum bits per second at 133MHz 16.625 Mbps
.program bclk_ser
.side_set 1 opt

pull_sample:
    pull noblock side 0                    ; get one 32-bit sample from the TX_FIFO
    irq set FSYNC_IRQ                     ; notify the sync pulse state machine that it's time
    set x, BIT_COUNTER                   ; bit loop counter
    jmp start_sample
sample_bits:
    nop side 0 [3]
start_sample:
    out pins, 1 side 1                   ; sample bit and bclk high
    jmp x-- sample_bits [2]                 ; get a new sample if 32 bits output


.program fsync
    set x, 0
.wrap_target
wait_irq:
    wait 1 IRQ FSYNC_IRQ
    jmp x-- wait_irq
    set pins 1 [7]
    set pins 0
    set x, CHANNEL_COUNTER

% c-sdk {
void tdm_output_init(PIO pio, uint bclk_offset, uint fsync_offset, uint base_pin) {

    // float clock_divider = 2.94518849206;  // 4 channels 32 bits 44.1KHz * 8 clk cycles/bit
    float clock_divider = 5.0;

    pio_sm_config bit_sm_config = bclk_ser_program_get_default_config(bclk_offset);
    pio_sm_config fsync_sm_config = fsync_program_get_default_config(fsync_offset);

    // set output and sideset pins, join the FIFOs to form a bigger TX FIFO
    sm_config_set_out_pins(&bit_sm_config, base_pin, 1);
    sm_config_set_sideset_pins(&bit_sm_config, base_pin + 1);
    sm_config_set_fifo_join(&bit_sm_config, PIO_FIFO_JOIN_TX);
    sm_config_set_clkdiv(&bit_sm_config, clock_divider);

    // set fsync output pin
    sm_config_set_set_pins(&fsync_sm_config, base_pin + 2, 1);
    sm_config_set_clkdiv(&fsync_sm_config, clock_divider);
    
    pio_sm_set_consecutive_pindirs(pio, 0, base_pin, 2, 1);
    pio_sm_set_consecutive_pindirs(pio, 1, base_pin + 2, 1, 1);

    pio_sm_init(pio, 0, bclk_offset, &bit_sm_config);
    pio_sm_init(pio, 1, fsync_offset, &fsync_sm_config);


    for(uint pin = base_pin; pin < base_pin + 3; pin++) {
        pio_gpio_init(pio, pin);
    }

}
%}